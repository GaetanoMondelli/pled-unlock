import { EventQueue } from './EventQueue';
import { EventProcessor } from './EventProcessor';
import { SimpleFSM } from './SimpleFSM';
import { ActionExecutor, ActionContext } from './ActionExecutor';
import { Event, Message, Rule, FSMDefinition, StateTransition } from './types';

/**
 * FSM Orchestrator - Coordinates all components
 * This is the main class that ties everything together
 */
export class FSMOrchestrator {
  private eventQueue: EventQueue;
  private eventProcessor: EventProcessor;
  private fsm: SimpleFSM;
  private actionExecutor: ActionExecutor;
  private rules: Rule[];
  private instanceId: string;
  private variables: Record<string, any>;

  constructor(
    fsmDefinition: FSMDefinition,
    rules: Rule[],
    instanceId: string,
    variables: Record<string, any> = {}
  ) {
    this.eventQueue = new EventQueue();
    this.eventProcessor = new EventProcessor();
    this.fsm = new SimpleFSM(fsmDefinition);
    this.actionExecutor = new ActionExecutor();
    this.rules = rules;
    this.instanceId = instanceId;
    this.variables = variables;
  }

  /**
   * Add a single event and process it
   */
  async addEvent(event: Event): Promise<{
    messages: Message[];
    transitions: StateTransition[];
    actionsExecuted: number;
  }> {
    this.eventQueue.addEvent(event);
    return this.processLatestEvents();
  }

  /**
   * Add multiple events and process them
   */
  async addEvents(events: Event[]): Promise<{
    messages: Message[];
    transitions: StateTransition[];
    actionsExecuted: number;
  }> {
    this.eventQueue.addEvents(events);
    return this.processLatestEvents();
  }

  /**
   * Process all events in the queue
   */
  private async processLatestEvents(): Promise<{
    messages: Message[];
    transitions: StateTransition[];
    actionsExecuted: number;
  }> {
    const events = this.eventQueue.getEvents();
    const messages = this.eventProcessor.processEvents(events, this.rules);
    const transitions: StateTransition[] = [];
    let actionsExecuted = 0;

    // Process each message through the FSM
    for (const message of messages) {
      const transition = this.fsm.processMessage(message);
      if (transition) {
        transitions.push(transition);

        // Execute actions for the new state
        const actions = this.fsm.getActionsForState(transition.to);
        if (actions.length > 0) {
          const context: ActionContext = {
            currentState: transition.to,
            variables: this.variables,
            instanceId: this.instanceId
          };

          const results = await this.actionExecutor.executeActions(actions, context);
          actionsExecuted += results.filter(r => r.success).length;

          // Add any events generated by actions back to the queue
          for (const result of results) {
            if (result.success && result.events.length > 0) {
              this.eventQueue.addEvents(result.events);
            }
          }
        }
      }
    }

    return {
      messages,
      transitions,
      actionsExecuted
    };
  }

  /**
   * Get current state
   */
  getCurrentState(): string {
    return this.fsm.getCurrentState();
  }

  /**
   * Get all events in queue
   */
  getEvents(): Event[] {
    return this.eventQueue.getEvents();
  }

  /**
   * Clear the event queue
   */
  clearEvents(): void {
    this.eventQueue.clear();
  }

  /**
   * Get possible transitions from current state
   */
  getPossibleTransitions(): string[] {
    const currentState = this.fsm.getCurrentState();
    return this.fsm.getAllTransitions()
      .filter(t => t.from === currentState)
      .map(t => t.trigger);
  }

  /**
   * Force a state change (for testing/debugging)
   */
  setState(state: string): void {
    this.fsm.setState(state);
  }

  /**
   * Get all states
   */
  getAllStates(): string[] {
    return this.fsm.getAllStates();
  }

  /**
   * Update variables
   */
  updateVariables(newVariables: Record<string, any>): void {
    this.variables = { ...this.variables, ...newVariables };
  }

  /**
   * Get variables
   */
  getVariables(): Record<string, any> {
    return { ...this.variables };
  }

  /**
   * Update rules
   */
  updateRules(newRules: Rule[]): void {
    this.rules = newRules;
  }

  /**
   * Get statistics
   */
  getStats(): {
    eventsProcessed: number;
    currentState: string;
    queueSize: number;
    variables: Record<string, any>;
  } {
    return {
      eventsProcessed: this.eventQueue.size(),
      currentState: this.fsm.getCurrentState(),
      queueSize: this.eventQueue.size(),
      variables: this.variables
    };
  }
}